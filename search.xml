<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>xv6 book 笔记</title>
      <link href="/2024/09/de32e36c091a.html"/>
      <url>/2024/09/de32e36c091a.html</url>
      
        <content type="html"><![CDATA[<h1 id="xv6-book"><a href="#xv6-book" class="headerlink" title="xv6 book"></a>xv6 book</h1><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h2 id="chapter-2"><a href="#chapter-2" class="headerlink" title="chapter 2"></a>chapter 2</h2><h3 id="operating-system-organization"><a href="#operating-system-organization" class="headerlink" title="operating system organization"></a>operating system organization</h3><p>There are three key requirements must fulfilled：multiplexing, isolation, and interaction.</p><p>This chapter will demonstrate above three requirements by providing an overview of xv6’s process (unit of isolation) and the creation of the first process when xv6 starts.</p><p>XV6 is written in ‘LP64’C, which means long (L) and pointers (P) in the C programming language are 64 bits, but an int is 32 bits.</p><h3 id="2-1-abstracting-physical-resources"><a href="#2-1-abstracting-physical-resources" class="headerlink" title="2.1 abstracting physical resources"></a>2.1 abstracting physical resources</h3><p>Abstracting physical resources is very necessary.</p><h3 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h3><p>Operating system need strong isolation，it means os or other applications can’t fail when a application makes a mistake.Instead,the os should be able to clean up the failed application and continue running other applications.Therefore, applications can’t modify os’data, instructions and access other applications’ memory.</p><p>CPUs have some support for strong isolation. For example, RISC-V has three modes in which the CPU can execute instructions: machine mode, supervisor mode, and user mode.</p><pre><code>machine mode:     - have full privilege;    - a CPU starts in machine mode;    - mostly intended for setting up the computer during boot;supervisor mode:    - the CPU is allowed to execute privileged instructions(特权指令);    - if an app in user mode attempts to execute a privileged instructions,CPU     doesn&#39;t execute the instruction,but switches to supervisor mode so that     supervisor-mode code can terminate the application, because it did     something it shouldn’t be doing;    - some app running in supervisor mode(also can execute privileged     instructions)said to be running in kernel space is called the kernel;user mode:    - An application can execute only user-mode instructions and is said to be     running in user space;    - an application in user mode cannot invoke a kernel function directly;</code></pre><p>An application cannot invoke a kernel function directly.<br>CPUs provide a special instruction(‘ecall’ in RISC-V) that switches the CPU from user mode to supervisor mode(and enters the kernel).</p><p>Once the CPU has switched to supervisor mode, the kernel can then validate the arguments of the system call (e.g., check if the address passed to the system call is part of the application’s memory), decide whether the application is allowed to perform the requested operation (e.g., check if the application is allowed to write the specified file), and then deny it or execute it. It is important that the kernel control the entry point for transitions to supervisor mode.if the application could decide the kernel entry point, a malicious application could enter the kernel at a point where the validation of arguments is skipped.</p><h3 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h3><p>CPUs have three running mode，then it was a question that which part of OS should run in supervisor mode. There are two options to choose：entire operating system resides in the kernel (monolithic kernel) or part of the operating system is in the kernel, and the rest is on the outside(microkernel). xv6 is monolithic.</p><pre><code>monolithic kernel：    Property：    - the entire operating system consists of a single program running with     full hardware privilege.    - is convenient for OS designer.    - is easier for different part of OS to cooperate.    Downside：    - interactions in the OS are often complex.    - fatal！a litle error could cause the kernel to fail and the computer     stops working, and thus all applications fail too.microkernel:    Property：    - minimize the amount of operating system code that runs in supervisor     mode.    - execute the bulk of the operating system in user mode.    - OS services running as processes in user mode are called servers(such as     File server).    - kernel provides a an inter-process communication mechanism for user-mode     processes.    - the kernel interface consists of a few low-level functions for starting     applications, sending messages, accessing device hardware, etc.</code></pre><p><img src="/../../Resources/Pasted%20image%2020241024125633.png"></p><h3 id="2-4-Code-xv6-organization"><a href="#2-4-Code-xv6-organization" class="headerlink" title="2.4 Code: xv6 organization"></a>2.4 Code: xv6 organization</h3><ul><li><p>The xv6 kernel source is in the kernel&#x2F;sub-directory.</p></li><li><p>The source is divided into files, following a rough notion of modularity.<br><img src="/../../Resources/Pasted%20image%2020241024125716.png"></p></li><li><p>The inter-module interfaces are defined in defs.h (kernel&#x2F;defs.h).</p></li></ul><h3 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5 Process overview"></a>2.5 Process overview</h3><p>The unit of isolation in OS is a process. One process can’t wrecking or spying on another process’s(of course include kernel itself) memory, CPU, file descriptors, etc.  The mechanisms used by the kernel to implement processes include the <em>user&#x2F;supervisor mode flag, address spaces, and time-slicing of threads.</em></p><p>Xv6 uses <em>page tables</em> (which are implemented by hardware) to give each process its own address space. The RISC-V page table translates (or “maps”) a virtual address (the address that an RISC-V instruction manipulates) to a physical address (an address that the CPU sends to main memory).</p><p>Each process have own page table. Page tables defines process’s address space.<br>An address space includes the process’s user memory starting at virtual address zero. </p><ul><li>Instructions come first,</li><li>followed by global variables,</li><li>then the stack, </li><li>and finally a “heap” area (for malloc) that the process can expand as needed. </li><li>the trampoline page(4096 bytes)  contains the code to transition in and out of the kernel,</li><li>the trapframe is where the kernel saves the process’s user registers,</li></ul><p>Some factors limit the maximum size of a process’s address space: </p><ul><li>pointers on the RISC-V are 64 bits wide; </li><li>the hardware uses only the low 39 bits when looking up virtual addresses in page tables;</li><li>and xv6 uses only 38 of those 39 bits. </li><li>Thus, the maximum address is 238 − 1 &#x3D; 0x3fffffffff, which 26 is MAXVA (kernel&#x2F;riscv.h:378).</li></ul><p><img src="/../../Resources/Pasted%20image%2020241026195937.png"></p><h4 id="struct-“proc”"><a href="#struct-“proc”" class="headerlink" title="struct “proc”"></a>struct “proc”</h4><p>The xv6 kernel gathers many pieces of state for each process into a struct proc(kernel&#x2F;proc.h:85). Most important state are page tables, kernel stack and run state. Use the notation p-&gt;xxx to refer to elements of the proc structure.</p><p>p-&gt;state:<br>    indicates whether the process is allocated, ready to run, currently running on a CPU, waiting for I&#x2F;O, or exiting.</p><p>p-&gt;pagetable:<br>    holds the process’s page table, A process’s page table also serves as the record of the addresses of the physical pages allocated to store the process’s memory.</p><h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p>Each process has a thread of control. The thread holds the state needed to execute the process.<br>A thread either executing on a CPU, or suspended(capable of resuming executing in the feture).<br>When CPU will switch to another process, the kernel:</p><ol><li>suspends the running thread </li><li>saves running thread’s state</li><li>restores the state of another process’s previously-suspended thread</li></ol><h4 id="stacks"><a href="#stacks" class="headerlink" title="stacks"></a>stacks</h4><p>Much of the state(local variables, function call return addresses) is stored on the thread’s stcaks. Each process has two stacks: a user stack and a kernel stack (p-&gt;kstack).<br>When the process is executing user instructions, only its user stack is in use, and its kernel stack is empty.When the process enters the kernel (for a system call or interrupt), the kernel code executes on the process’s kernel stack.<br>The kernel stack is separate (and protected from user code) so that the kernel can execute even if a process has wrecked its user stack.</p><h4 id="come-and-go-kernel"><a href="#come-and-go-kernel" class="headerlink" title="come and go kernel"></a>come and go kernel</h4><p>A process can make a system call by executing the RISC-V ecall instruction.<br><em>ecall</em> instruction:</p><ul><li>This instruction raises the hardware privilege level</li><li>changes the program counter to a kernel-defined entry point</li><li>The code at the entry point switches to kernel stack and executes the kernel instructions that implement the system call.</li></ul><p>When the system call completes, the kernel switches back to the user stack and returns to user space by calling the sret instruction.<br><em>sret</em> instruction:</p><ul><li>lowers the hardware privilege level</li><li>resumes executing user instructions just after the system call instruction</li></ul><p>A process’s thread can “block” in the kernel to wait for I&#x2F;O, and resume where it left off when the I&#x2F;O has finished.</p><p>**In summary, a process bundles two design ideas: an address space to give a process the illusion of its own memory, and a thread to give the process the illusion of its own CPU. **</p><h3 id="2-6-Code-starting-xv6-the-first-process-and-system-call"><a href="#2-6-Code-starting-xv6-the-first-process-and-system-call" class="headerlink" title="2.6 Code: starting xv6, the first process and system call"></a>2.6 Code: starting xv6, the first process and system call</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1810 学习资料</title>
      <link href="/2024/07/a009a5ae80d3.html"/>
      <url>/2024/07/a009a5ae80d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="6-1810-课程资料-amp-学习记录"><a href="#6-1810-课程资料-amp-学习记录" class="headerlink" title="6.1810 课程资料&amp;学习记录"></a>6.1810 课程资料&amp;学习记录</h1><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong><a href="https://pdos.csail.mit.edu/6.828/2024/">官网</a></strong><br><strong>教材：<a href="https://pdos.csail.mit.edu/6.828/2024/xv6/book-riscv-rev4.pdf">xv6 book</a></strong><br><strong>B站视频：<a href="https://www.bilibili.com/video/BV19k4y1C7kA?p=1&vd_source=663806180f4de3dcdba03f194f1b2c9e">MIT 6.S081 2020 操作系统 [中英文字幕]</a></strong></p><h2 id="LEC-1-rtm"><a href="#LEC-1-rtm" class="headerlink" title="LEC 1 (rtm):"></a>LEC 1 (rtm):</h2><h3 id="Introduction-and-examples-handouts-xv6-book-2020-video"><a href="#Introduction-and-examples-handouts-xv6-book-2020-video" class="headerlink" title="Introduction and examples (handouts: xv6 book; 2020: video)"></a><a href="https://pdos.csail.mit.edu/6.828/2021/slides/6s081-lec-intro.pdf">Introduction</a> and examples (handouts: xv6 book; 2020: video)</h3><p>Preparation: Read chapter 1 (for your amusement: Unix)<br>Assignment: <a href="https://pdos.csail.mit.edu/6.828/2024/labs/util.html">Lab util: Unix utilities</a></p><h3 id="任务列表："><a href="#任务列表：" class="headerlink" title="任务列表："></a>任务列表：</h3><ul><li><input checked="" disabled="" type="checkbox"> Read chapter 1</li><li><input checked="" disabled="" type="checkbox"> video:Lecture 1 - Introduction and Examples</li><li><input checked="" disabled="" type="checkbox"> Lab util: Unix utilities<ul><li><input checked="" disabled="" type="checkbox"> Boot xv6</li><li><input checked="" disabled="" type="checkbox"> sleep</li><li><input checked="" disabled="" type="checkbox"> pingpong</li><li><input checked="" disabled="" type="checkbox"> primes</li><li><input checked="" disabled="" type="checkbox"> find</li><li><input checked="" disabled="" type="checkbox"> xargs</li></ul></li></ul><h2 id="LEC-2-fk"><a href="#LEC-2-fk" class="headerlink" title="LEC 2 (fk):"></a>LEC 2 (fk):</h2><h3 id="C-in-xv6-slides-c-gdb-and-examples"><a href="#C-in-xv6-slides-c-gdb-and-examples" class="headerlink" title="C in xv6, slides,c, gdb,and examples"></a><a href="https://pdos.csail.mit.edu/6.828/2021/lec/6S081-Intro-to-C-Fa21.pdf">C in xv6</a>, <a href="https://pdos.csail.mit.edu/6.828/2024/lec/l-c_slides.pdf">slides</a>,<a href="https://pdos.csail.mit.edu/6.828/2021/lec/6S081-Intro-to-C-Fa21.pdf">c</a>, <a href="https://pdos.csail.mit.edu/6.828/2021/lec/gdb_slides.pdf">gdb</a>,and examples</h3><p>Preparation: 2.9 (Bitwise operators) and 5.1 (Pointers and addresses) through 5.6 (Pointer arrays) and 6.4 (pointers to structures) by Kernighan and Ritchie (K&amp;R)</p><h3 id="任务列表：-1"><a href="#任务列表：-1" class="headerlink" title="任务列表："></a>任务列表：</h3><ul><li><input checked="" disabled="" type="checkbox"> C in xv6</li><li><input disabled="" type="checkbox"> slides</li><li><input disabled="" type="checkbox"> c</li><li><input disabled="" type="checkbox"> gdb</li></ul><h2 id="LEC-3-fk"><a href="#LEC-3-fk" class="headerlink" title="LEC 3 (fk):"></a>LEC 3 (fk):</h2><h3 id="OS-design-OS-organization-and-system-calls-2020-video"><a href="#OS-design-OS-organization-and-system-calls-2020-video" class="headerlink" title="OS design,OS organization and system calls (2020: video)"></a>OS design,<a href="https://pdos.csail.mit.edu/6.828/2021/slides/6s081-lec-osorg.pdf">OS organization and system calls</a> (2020: video)</h3><p>Preparation: Read chapter 2 and xv6 code: <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.h">kernel&#x2F;proc.h</a>, <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/defs.h">kernel&#x2F;defs.h</a>, <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/entry.S">kernel&#x2F;entry.S</a>, <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/main.c">kernel&#x2F;main.c</a>, <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/initcode.S">user&#x2F;initcode.S</a>, <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/init.c">user&#x2F;init.c</a>, and skim <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.c">kernel&#x2F;proc.c</a> and <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/exec.c">kernel&#x2F;exec.c</a><br>Assignment: <a href="https://pdos.csail.mit.edu/6.828/2024/labs/syscall.html">Lab syscall: System calls(24)</a><a href="https://pdos.csail.mit.edu/6.828/2021/labs/syscall.html">21</a></p><h3 id="任务列表：-2"><a href="#任务列表：-2" class="headerlink" title="任务列表："></a>任务列表：</h3><ul><li><input disabled="" type="checkbox"> Read chapter 2 (2024&#x2F;10&#x2F;1-)</li><li><input disabled="" type="checkbox"> video:Lecture 3 - OS Organization and System Calls</li><li><input disabled="" type="checkbox"> Lab syscall: System calls<ul><li><input disabled="" type="checkbox"> Using gdb</li><li><input disabled="" type="checkbox"> System call tracing</li><li><input disabled="" type="checkbox"> Attack xv6</li><li><input disabled="" type="checkbox"> Sysinfo</li></ul></li></ul><p>LEC 4 (fk): page tables<br>Preparation: Read Chapter 3 and kernel&#x2F;memlayout.h, kernel&#x2F;vm.c, kernel&#x2F;kalloc.c, kernel&#x2F;riscv.h, and kernel&#x2F;exec.c</p><p>LEC 4 (ab): Page tables (2020: notes, boards, video)<br>Preparation: Read Chapter 3 and kernel&#x2F;memlayout.h, kernel&#x2F;vm.c, kernel&#x2F;kalloc.c, kernel&#x2F;riscv.h, and kernel&#x2F;exec.c</p><p>LEC 5 (rtm): System call entry&#x2F;exit<br>Preparation: Read Chapter 4, except 4.6 and kernel&#x2F;riscv.h, kernel&#x2F;trampoline.S, and kernel&#x2F;trap.c<br>Assignment: Lab pgtbl: Page tables</p><p>LEC 5 (TAs): GDB, calling conventions and stack frames RISC-V (2020: notes, boards, video)<br>Preparation: Read Calling Convention<br>Assignment: Lab pgtbl: Page tables</p><p>LEC 6 (TAs): GDB Calling conventions<br>Preparation: Read Calling Convention</p><p>LEC 6 (ab): Isolation &amp; system call entry&#x2F;exit (2020: notes, video)<br>Preparation: Read Chapter 4, except 4.6 and kernel&#x2F;riscv.h, kernel&#x2F;trampoline.S, and kernel&#x2F;trap.c</p><p>LEC 7 (fk): Page faults (slides)<br>Preparation: Read Section 4.6<br>Assignment: Lab traps: Traps</p><p>LEC 7 (ab): Page faults (2020: notes, boards, video)<br>Preparation: Read Section 4.6<br>Assignment: Lab traps: Traps</p><p>LEC 8 (fk): Q&amp;A labs (slides)</p><p>LEC 8 (ab): Q&amp;A labs</p><p>LEC 9 (fk): Device drivers<br>Preparation: Read Chapter 5 and kernel&#x2F;kernelvec.S, kernel&#x2F;plic.c, kernel&#x2F;console.c, kernel&#x2F;uart.c, kernel&#x2F;printf.c<br>Assignment: Lab cow: Copy-on-write fork</p><p>LEC 9 (ab): Interrupts (2020: notes, boards, video)<br>Preparation: Read Chapter 5 and kernel&#x2F;kernelvec.S, kernel&#x2F;plic.c, kernel&#x2F;console.c, kernel&#x2F;uart.c, kernel&#x2F;printf.c<br>Assignment: Lab cow: Copy-on-write fork</p><p>LEC 10 (fk): Locking<br>Preparation: Read “Locking” with kernel&#x2F;spinlock.h and kernel&#x2F;spinlock.c</p><p>LEC 10 (ab): Multiprocessors and locking (2020: notes, boards, video)<br>Preparation: Read “Locking” with kernel&#x2F;spinlock.h and kernel&#x2F;spinlock.c</p><p>LEC 11 (rtm): Scheduling 1<br>Preparation: Read “Scheduling” through Section 7.4, and kernel&#x2F;proc.c, kernel&#x2F;swtch.S</p><p>LEC 11 (ab): Scheduling 1 (2020: notes, video)<br>Preparation: Read “Scheduling” through Section 7.4, and kernel&#x2F;proc.c, kernel&#x2F;swtch.S</p><p>LEC 12 (rtm): Coordination, code<br>Preparation: Read remainder of “Scheduling”, and corresponding parts of kernel&#x2F;proc.c, kernel&#x2F;sleeplock.c</p><p>LEC 12 (ab): Scheduling 2 (2020: notes, code, video)<br>Preparation: Read remainder of “Scheduling”, and corresponding parts of kernel&#x2F;proc.c, kernel&#x2F;sleeplock.c<br>Assignment: Lab thread: Multithreading</p><p>LEC 13 (fk): File systems (slides)<br>Preparation: Read kernel&#x2F;bio.c, kernel&#x2F;fs.c, kernel&#x2F;sysfile.c, kernel&#x2F;file.c and “File system” (except for the logging sections)</p><p>LEC 13 (ab): Q&amp;A labs</p><p>Midterm open book and notes<br>scope: Lectures 1 through 12, labs through lab cow<br>practice: previous quizzes.<br>Assignment: Lab net: Network driver</p><p>LEC 14 (fk): Crash recovery (slides)<br>Preparation: Read kernel&#x2F;log.c and the logging sections of the “File system” chapter</p><p>LEC 14 (ab): File systems (2020: notes, boards, video)<br>Preparation: Read kernel&#x2F;bio.c, kernel&#x2F;fs.c, kernel&#x2F;sysfile.c, kernel&#x2F;file.c and “File system” (except for the logging sections)<br>Assignment: Lab net: Network driver</p><p>LEC 15 (rtm): File system performance and fast crash recovery<br>Preparation: Read Journaling the Linux ext2fs Filesystem (1998)</p><p>LEC 15 (ab): Crash recovery (2020: notes, boards, video)<br>Preparation: Read kernel&#x2F;log.c and the logging sections of “File system”</p><p>Hacking day: no class meeting; work on the lab<br>Assignment: Lab lock: Parallelism&#x2F;locking</p><p>LEC 16 (fk): Virtual memory for applications (baker example) (slides)<br>Preparation: Read Virtual Memory Primitives for User Programs (1991)<br>Assignment: Lab fs: File system</p><p>LEC 16 (ab): File system performance and fast crash recovery (2020: notes, video)<br>Preparation: Read Journaling the Linux ext2fs Filesystem (1998)</p><p>LEC 17 (rtm): OS Organization<br>Preparation: Read The Performance of micro-Kernel-Based Systems (1997)</p><p>LEC 17 (ab): Virtual memory for applications (2020: notes, boards, video) (baker example)<br>Preparation: Read Virtual Memory Primitives for User Programs (1991)</p><p>DROP DATE<br>LEC 18 (rtm): Virtual Machines<br>Preparation: Read Dune: Safe User-level Access to Privileged CPU Features (2012)<br>Hacking day: no class meeting; work on the lab<br>Assignment: Lab mmap: Mmap</p><p>LEC 18 (ab): OS Organization (2020: notes, video)<br>Preparation: Read The Performance of micro-Kernel-Based Systems (1997)<br>Assignment: Lab lock: Parallelism&#x2F;locking</p><p>LEC 19 (fk): Kernels and HLL<br>Preparation: Read the Biscuit paper (2018), FAQ</p><p>LEC 19 (ab): Virtual Machines (2020: notes, video)<br>Preparation: Read Dune: Safe User-level Access to Privileged CPU Features (2012)</p><p>LEC 20 (rtm): Networking<br>Preparation: Read Receive Livelock (1996)</p><p>LEC 20 (ab): Kernels and HLL] (2020: notes, slides, video)<br>Preparation: Read the Biscuit paper (2018), FAQ<br>Assignment: Lab fs: File system</p><p>LEC 21 (rtm): Meltdown<br>Preparation: Read Meltdown (2018)</p><p>LEC 21 (ab): Networking (2020: notes, video)<br>Preparation: Read Receive Livelock (1996)</p><p>Hacking day: no class meeting; work on the lab<br>DUE: Lab fs<br>Assignment: Lab mmap: Mmap</p><p>LEC 22 (rtm): Multi-Core scalability and RCU<br>Preparation: Read RCU paper (2013), FAQ</p><p>LEC 22 (ab): Meltdown (2020: notes, video)<br>Preparation: Read Meltdown (2018)</p><p>LAST DAY OF CLASSES<br>LEC 23 (tbd): Current Research</p><p>LEC 23 (ab): Multi-Core scalability and RCU (2020: notes, video)<br>Preparation: Read RCU paper (2013), FAQ</p><p>LEC 24 (TAs): Current Research: Radiation Tolerance<br>Preparation: Read NASA CALIPSO paper (2006) for background</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zz读书记录</title>
      <link href="/2023/03/156e5f0daf91.html"/>
      <url>/2023/03/156e5f0daf91.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="《马列毛基础教程》2019修订"><a href="#《马列毛基础教程》2019修订" class="headerlink" title="《马列毛基础教程》2019修订"></a>《马列毛基础教程》2019修订</h1><p><a href="https://drive.google.com/file/d/1nsVTnDRAEc_NRUWu0Yn7FRcmI_PzNjM5/view">马列毛基础教程</a></p><p>2023-3-1~3<br>第27页</p><hr><p>2023-3-4</p><p>28</p><h4 id="第五章-马克思主义的三大源头"><a href="#第五章-马克思主义的三大源头" class="headerlink" title="第五章 马克思主义的三大源头"></a>第五章 马克思主义的三大源头</h4><p>马克思主义的三个理论来源——德国古典哲学（辩证唯物主义）、英国古典政治经济学（马克思主义政治经济学）,以及法国空想社会主义理论（科学社会主义）</p><p>三个源头各有其进步和问题，马克思深入研究后汲取精髓，抛弃糟粕，最终形成马克思主义思想。</p><p>32<br>3-5</p><h4 id="第六章-马克思主义哲学的基本形式-辩证唯物主义和历史唯物主义"><a href="#第六章-马克思主义哲学的基本形式-辩证唯物主义和历史唯物主义" class="headerlink" title="第六章 马克思主义哲学的基本形式:辩证唯物主义和历史唯物主义"></a>第六章 马克思主义哲学的基本形式:辩证唯物主义和历史唯物主义</h4><p><strong>唯物主义还是唯心主义</strong>这个哲学上的基本分野涉及物质和意识的第一性问题。认为意识是世界本原的哲学家,属于唯心主义阵营,认为物质具有第一性的哲学家,则属于唯物主义阵营。崇尚实践并且坚决反对一切宗教信仰的马恩毅然选择唯物主义。</p><p>但是当时期的都是机械唯物主义（形而上学），马克思拒绝了机械唯物主义的<br>这种观点——因为这种唯物主义学说并不能给出关于历史。因此马克思转而研究辩证法（关于普遍规律的科学），而辩证法的实质在于,<strong>它从事物的内部联系,也就是事物的内在矛盾理解事物的运动、变化和发展</strong>。<br>但是辩证法的代表黑格尔是个唯心主义。马克思把黑格尔的辩证思维规律拓展到自然界和人类社会领域,创立了<strong>辩证唯物主义</strong>——马克思主义哲学的核心理论。<br>辩证法+唯物主义成为新的革命哲学，马恩运用辩证唯物主义分析社会历史，从而得出<strong>历史唯物主义</strong>。<br>唯物史观认为：社会变革的根据不在于某些伟人的创造性精神,而在于客观的历史进程。唯物史观的出发点是<strong>物质生产力的发展水平</strong>，包括劳动工具、机器以及劳动者的技巧等因素，根据生产力的发展水平可以得出一定的生产关系,即<strong>所有制关系——某些社会集团对生产手段的控制方式</strong>。因此,“手推磨产生的是封建主的社会,蒸汽磨产生的是工业资本家的社会。”<strong>这些生产关系构成了社会的经济结构,亦即社会经济基础。</strong><br>在经济基础的地基之上,矗立着政治和法律的上层建筑,以及特定的社会意识形式。（社会的内部联系）<br>在生产力发展的一定阶段上,落后的生产关系就会阻碍生产力的发展,（内部矛盾）<br><strong>在这种条件下,社会革命的时代就要来临了。社会革命之所以必须,是因为唯有社会革命才能够打破旧的生产关系,——这在阶级社会里表现为阶级关系——并代之以适应于生产力发展的生产关系。这样,整个社会的经济基础,进而受其制约的整个上层建筑,也就或快或慢地发生变革。</strong></p><p>37<br>3-9</p><h4 id="第七章-同空想社会主义的斗争和科学社会主义的构建"><a href="#第七章-同空想社会主义的斗争和科学社会主义的构建" class="headerlink" title="第七章 同空想社会主义的斗争和科学社会主义的构建"></a>第七章 同空想社会主义的斗争和科学社会主义的构建</h4><p>工人阶级同资产阶级一起推翻了不公的封建阶级，而资产阶级以虚假的自由和平等随即对工人阶级的再三压迫，导致了工人阶级的反抗，社会主义学说的出现，由于资本主义社会是无序生产的，一帮思想家试图建立一个完美的有序的社会形态，但是由于不是基于对社会现实的分析，不是以社会内部关系和矛盾的为出发点，既不能实现理想，也没有意识到为了实现社会主义，阶级斗争，社会革命的重要性和必然性。<br>马恩让社会主义成为科学的主义，让大家明白了社会主义的必然性，指出社会主义者的工作内容和方向，获得了全球的支持，成立了“共产主义同盟”，发表了《共产党宣言》。</p><p>40</p><h4 id="第八章-马克思主义政治经济学"><a href="#第八章-马克思主义政治经济学" class="headerlink" title="第八章 马克思主义政治经济学"></a>第八章 马克思主义政治经济学</h4><p>马克思从经济最基本的单位-商品-出发,揭示了资本主义经济规律的本质。从而揭示了社会主义革命和通向共产主义的道路的科学经济基础。<br>工人付出劳动力得到工资，这两者如果等价，资本家将一无所获，因此报酬一定会小于付出，额外的利润称之为<strong>剩余价值</strong>，被资本家获得，它是资产阶级的利润之源和财富之源。<br>这产生的主要阶级矛盾是社会性的生产和私人占有的生产资料的矛盾，资本主义经济危机正是因为资本家加大剥削力度，工人没钱购买商品，一方面生产扩大,另一方面市场收缩之间的严重矛盾。结果是出现了生产过剩的危机,市场上充斥着未售出的商品。许多资本家破产了。成千上万的工人下岗。</p><p>45<br>3-10</p><h4 id="第九章-马克思主义与工人阶级的联系"><a href="#第九章-马克思主义与工人阶级的联系" class="headerlink" title="第九章 马克思主义与工人阶级的联系"></a>第九章 马克思主义与工人阶级的联系</h4><ul><li>1848年马恩领导共产主义者同盟，起草共产党宣言，在德意志创办《新莱茵报》，该报支持资本主义激进派的资产阶级民主革命，同时是德意志新兴无产阶政党的组织方。坚持一年后革命失败</li><li>失败后马克思初次尝试用历史唯物主义解释当下的历史事件。他透彻地分析了革命中一次次峰回<br> 路转背后的阶级力量,为无产阶级革命战术的制定提供了阶级分析的基础，同时组织地方工人小团体。同盟1852年11月被迫解散。<br> 恩格斯回到父亲公司上班20年，对马克思提供资金支持和工作帮助。</li><li>1864年成立国际工人协会（第一国际），第一国际不比同盟，工人思想水平不足，马克思成为领导人，几乎为第一国际起草了所有重要文件。</li><li>1871年巴黎公社成立，马克思主义思想再也不是局限于几个小团体内的思想,而成为了一种大众现象,它的影响力扩展到不同国家的工人运动中,领导了一系列工人运动,给资产阶级以巨大的挑战。马克思主义已经和广大工人群众紧紧联系在一起。</li></ul><p>51</p><h4 id="第十章-从巴黎公社中所学到的"><a href="#第十章-从巴黎公社中所学到的" class="headerlink" title="第十章 从巴黎公社中所学到的"></a>第十章 从巴黎公社中所学到的</h4><p>1870-1871拿破仑三世发动普法战争，战败投降，普鲁士与一些小省份1871年1月合并为德国，法国成立共和国，与德国签署和平条约，然而,自 1870 年 9 月以来一直被普鲁士军队包围的巴黎并没有服从共和国。它由巴黎国民自卫队控制,巴黎国民自卫队主要由工人组成。工人夺权成立公社，德法联合粉碎了公社。<br>在初期马克思反对独立，呼吁承认法兰西共和国，但在巴黎有一些追随者的各种无政府主义者和阴谋主义者的积极分子在组织起义方面做尝试，革命发生时马克思立刻转而支持公社，恩格斯作为军事专家提供防御建议。<br>马克思立即将巴黎公社革命称为具有重大历史意义的事件,并对它进行了深入分析,试图从其经验中汲取教训。《法兰西内战》这本著作是在公社革命期间写成的,但在公社垮台两天后才完成。它宣传了巴黎公社的成就,并让世界各地的革命者和工人正确地认识巴黎公社。</p><p>公社的所有决定都清楚地带有无产阶级行动的印记。面对绝望的生存困境,但公社通过其行动首次提供了即将到来的无产阶级革命所带来的社会。它提供了无产阶级第一次掌握国家政权的经验——马克思和恩格斯称之为第一个无产阶级专政。</p><p>公社的一个严重弱点是缺乏一个无产阶级政党明确和集中的领导。马克思从中得出结论,为了革命的胜利,一个强大、有远见和纪律严明的无产阶级政党必须领导革命。<br>马克思反复强调的另一点是需要粉碎过去的国家机器。</p><p>56</p><h4 id="第十一章-马克思主义的传播和机会主义的兴起"><a href="#第十一章-马克思主义的传播和机会主义的兴起" class="headerlink" title="第十一章 马克思主义的传播和机会主义的兴起"></a>第十一章 马克思主义的传播和机会主义的兴起</h4><p>3-11<br>第一国际的兴衰，和机会主义在国际运动中的扎根和维系，包括之后的第二国际。<br>但是并没有解释机会主义出现的本质和顽固的缘由，我想应该不是人性的原因。<br>机会主义的代表是拉萨尔主义，修正主义的代表是伯恩施坦主义。<br>机会主义攻击不倒马克思主义，于是化身修正主义，修正主义不愿意暴力革命，愿意和zf妥协，幻想通过资本主义本身过渡到社会主义。</p><p>60</p><h4 id="第十二章-马克思主义在俄国-—-列宁的早年生活"><a href="#第十二章-马克思主义在俄国-—-列宁的早年生活" class="headerlink" title="第十二章 马克思主义在俄国 — 列宁的早年生活"></a>第十二章 马克思主义在俄国 — 列宁的早年生活</h4><p>67</p><h4 id="第十三章-列宁及其新式无产阶级政党"><a href="#第十三章-列宁及其新式无产阶级政党" class="headerlink" title="第十三章 列宁及其新式无产阶级政党"></a>第十三章 列宁及其新式无产阶级政党</h4><p>《怎么办？》发起了对经济派的直接攻击。列宁揭露了经济派的观点是如何屈服于工人阶级运动的自发性,忽视了党的意识和主导作用。他表明这将如何导致工人阶级被资本主义奴役。经济派在颂扬马克思主义的同时,却想把革命党变成一个社会改良政党。<br>俄国马克思主义党派分裂成布尔什维克和孟什维克两派</p><p>72</p><h4 id="第十四章-一九〇五俄国资产阶级革命无产阶级革命策略的发展"><a href="#第十四章-一九〇五俄国资产阶级革命无产阶级革命策略的发展" class="headerlink" title="第十四章 一九〇五俄国资产阶级革命无产阶级革命策略的发展"></a>第十四章 一九〇五俄国资产阶级革命无产阶级革命策略的发展</h4><p>3-16</p><p>190几年时期在亚洲出现革命的高潮，其中最重要的是1905年俄国的革命，而其起点便是日俄战争。1904 年 2 月 8 日开始的日俄战争,其结束是在 1905年 8 月 23 日以沙皇战败和签订一个羞辱性的和平条约告终。<br>1900-1903的经济危机和沙皇的失败对其的削弱加快了革命的到来，于是1905年伟大革命到来。整个 1905 年,工人进行激进的政治罢工,农民夺取地主的土地粮食。为了转移斗争,沙皇首先设立了杜马（议会）,布尔什维克抵制杜马，认为革命应由无产阶级领导，武装起义推翻沙皇，孟什维克决定参加，采取改良主义，并认为革命应由自由资产阶级领导。<br>1905 年的 10 月至 12 月,无产阶级在世界历史上第一次建立了工人代表苏维埃——这是由所有工厂的代表组成的。它们是革命力量的萌芽,是 1917 年社会主义革命后建立的苏维埃政权的模板。最后遭到沙皇镇压。<br>尽管 1905 年革命失败了,但却动摇了沙皇统治的基础。在短短的三年时间内为工人阶级和农民提供了丰富的政治教育。这个时期,布尔什维克在实践中证明了他们对无产阶级战略和策略的革命性观点是基本正确的。布尔什维克对革命的朋友和敌人以及斗争形式和组织形式的观点已经在这场革命的过程中得到牢固确立。</p><p>列宁在《社会民主党在民主革命中的两种策略》一书中。这本书写于布尔什维克和孟什维克分裂的大会之后的 1905 年 7 月,揭示了两个派别提出的战略和策略的本质区别。</p><ol><li>无产阶级必须是革命领导。</li><li>人民武装起义是胜利的最有效手段。</li><li>革命的目的不是资产阶级革命胜利，党的责任是尽一切可能使资产阶级民主革命过渡到社会主义革命。他因此给马克思不断革命的概念提供了具体的形式。</li></ol><p>78</p><h4 id="第十五章-第一次世界大战-机会主义兴起与革命策略的发展"><a href="#第十五章-第一次世界大战-机会主义兴起与革命策略的发展" class="headerlink" title="第十五章 第一次世界大战:机会主义兴起与革命策略的发展"></a>第十五章 第一次世界大战:机会主义兴起与革命策略的发展</h4><p>机会主义在第二国际内部腐朽，其对于战争的观点，对殖民的立场都已经扭曲。<br>列宁澄清战争的革命立场，成立第三国际。</p><p>83</p><h4 id="第十六章-列宁对资本主义最高阶段帝国主义的分析"><a href="#第十六章-列宁对资本主义最高阶段帝国主义的分析" class="headerlink" title="第十六章 列宁对资本主义最高阶段帝国主义的分析"></a>第十六章 列宁对资本主义最高阶段帝国主义的分析</h4><p>3-17<br>太复杂，没咋看懂<br>3-23补<br>在马克思时期，资本主义还是竞争阶段，马克思未能看到资本主义新阶段——帝国主义阶段。帝国主义出现在二十世纪初，随着帝国主义引起的一战的开始,列宁认为有必要对帝国主义进行充分的分析,以了解战争的经济基础和对无产阶级的政治后果。<br>1915 年,机会主义者和修正主义领导人——第二国际的<strong>卡尔·考茨基</strong>写了一本关于帝国主义的书,他认为世界经济体系正在走向“超帝国主义”,未来国际社会将是稳定的,没有战争的危险。他们认为,由于跨国集团和公司的成长,以及它们的资本向所有国家的扩散,这些跨国公司将反对战争,因此不存在爆发世界大战的危险。<br>由于这样一个错误的理论是由考茨基提出的,他当时被公认为马克思主义的主要理论家,因此绝对有必要反对这一理论并提出正确的理解。必须清除第二国际主义者并对国际工人阶级运动进行正确的分析,提出正确的策略。列宁在 1916 年进行了广泛的研究,并创作出了著作《帝国主义是资本主义的最高阶段》。除了这一主要著作外,他还写了许多其他的文章,把基本的经济分析与无产阶级的策略联系起来。<br>资本主义的本质：<br>首先澄清“<strong>帝国主义是什么</strong>”的问题。列宁指出：帝国主义是资本主义的一个特定的历史阶段。它的具体特点有三方面:帝国主义是(1)垄断资本主义;(2)寄生或腐朽的资本主义;(3)垂死的资本主义或临终的资本主义。<strong>垄断取代自由竞争是帝国主义的根本经济特征,是帝国主义的本质</strong>。</p><p>垄断资本主义其表现形式有五种:<br>(1)垄断组织、集团、国际垄断联盟——他们的生产集中程度到达新的阶段，以至于形成对其他资本家镇压的垄断协会。防止其他新的资本家进入行业或者取得成功。<br>(2)大银行的垄断地位和垄断产业资本与银行资本合作创造金融资本。<br>(3)特别重要的资本输出——这一特点不同于非垄断资本主义下的商品出口,它与世界的经济和政治分治密切相关。<br>(4)国际垄断联盟对世界经济的分割——在列宁时代,已经有一百多个这样的国际垄断组织,它们控制着整个世界市场,并以“友好”的方式将其分割开来。当然,这种“友好”只是暂时的,并且会持续到战争发生,以重新划分市场。<br>(5)最大的资本主义国家对世界(殖民地)的领土(政治)划分——世界上所有落后国家的殖民化进程,基本上是在帝国主义开始时完成的。任何进一步的殖民地都只能通过重新划分世界,通过战争才能得到。<br>资本主义的最终定义：<br>列宁根据上述特点,对帝国主义作出如下定义:“<strong>帝国主义是发展到垄断组织和金融资本的统治已经确立、资本输出具有突出意义、国际托拉斯开始瓜分世界、一些最大的资本主义国家已把世界全部领土瓜分完毕这一阶段的资本主义。</strong>”</p><p>帝国资本主义的两大特征：<br><strong>寄生的，腐朽的</strong>：<br>    1. 与自由竞争条件下的快速扩张相比,垄断下的整体<strong>生产有下降的趋势</strong>。技术进步受到阻碍,新发明和专利被故意压制。<br>    2. 资本主义的衰败表现在创造了一个庞大的阶层,即<strong>资本家,他们生活在没有工作的情景下</strong>,仅仅根据他们的投资所赚取的利息或红利而生活。<br>    3 .资本的输出是高寄生性的,因为它意味着<strong>对落后国家廉价劳动力的公开剥削</strong>。<br>    4. 金融资本追求的是统治,而不是自由。政治反动始终是帝国主义的一个特征。<strong>腐败、大规模贿赂</strong>和各种欺诈行为屡见不鲜。<br>    5. 对被压迫民族的剥削,特别是少数“大国”对殖民地的剥削,日益将帝国主义世界变成落后国家中数亿人身上的寄生虫。它达到了这样的阶段:在帝国主义国家中,一个享有特权的无产阶级上层阶层也部分地以牺牲殖民地数亿人的利益为代价生活。<br><strong>垂死的</strong>：<br>    帝国主义是垂死的资本主义,因为它是向社会主义过渡的资本主义。<br>    帝国主义对劳动惊人的社会化，资本主义生产的社会性质与所有制的私有制之间的基本矛盾,在帝国主义的作用下才进一步加剧。因此列宁这样说:“帝国主义是无产阶级社会革命的前夜。”</p><p>87</p><h4 id="第十七章-伟大的十月革命"><a href="#第十七章-伟大的十月革命" class="headerlink" title="第十七章 伟大的十月革命"></a>第十七章 伟大的十月革命</h4><p>3-21<br>1905年的革命失败后，俄国工人阶级和革命分子受到沙皇总理极端镇压，布尔什维克从进攻策略（总罢工和武装起义等）转而成防御策略（以聚集力量为基本目的），如干部转入地下工作，由幸存的合法工人组织掩护，通过其建立党和群众的联系。<br>同时期运动出现两个不正确倾向，取消派（孟什维克支持关闭非法组织建立合法劳工政党）和召回派（部分布尔什维克只想要非法组织，想召回合法组织中的成员），这都阻止了日后推动革命的力量的聚集。布尔什维克拒绝了遮脸肿倾向，成功发展了组织聚集了力量，为1912年革命高潮做好了准备。<br>1911年罢工人数增加，布尔什维克组成单独政党俄国社会民主党（布尔什维克），举行党派会议，预测了革命高潮的到来，确定了新的策略——创办《真理报》，早些时候,布尔什维克有一份周报,专门针对先进工人。然而,《真理报》是一份日常的大众政治报纸,旨在向最广泛的工人群体伸出援助之手。“1912 年的《真理报》为布尔什维主义 1917 年的胜利奠定了基础。”（斯大林）<br>1914年战争爆发，布尔什维克在工人和士兵之间宣传反对战争推翻沙皇，1917年人民生活困境愈发严重，革命形式走向成熟。<br>1917年1月开始在一些工业中心开始了强大的革命运动。布尔什维克组织大型总罢工，2月2日（3月8）国际妇女节女工们响应布尔什维克彼得格勒委员会的号召,上街游行示威,反对饥饿,反对战争,反对沙皇制度。工人们通过罢工支持劳动妇女,到 3 月 11 日,罢工和示威活动转化为武装起义。中央委员会于 3 月 11 日发出呼吁,要求继续武装起义推翻沙皇并建立临时革命政府。3 月 12 日,60000 名士兵站到革命的一边,与警察作战并帮助工人推翻沙皇。随着消息的传播,各地的工人和士兵开始罢免沙皇官员。二月资产阶级民主革命获胜。(它被称为<strong>二月革命</strong>,因为当时的俄罗斯历法比世界其他地区的历法晚 13 天,根据俄罗斯历法,革命胜利的日期是 2 月 27 日)。</p><p>3-22</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zz书 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
